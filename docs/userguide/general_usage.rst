.. _general:

===============================================================================
General Overview
===============================================================================
Before diving into the detailed workings of each OpenPNM module, it is worthwhile to give a general overview of the common features shared by each object. As mentioned, the OpenPNM objects descend from the Python ``dict`` object, and have additional methods added.  This section will outline the inheritance structure and document the various methods that are common to each all OpenPNM objects.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Base Class
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
The Base class descends directly from ``dict``.  It contains very high level functionality, specifically: the logger and it's associated machinery, methods for looking-up names and retrieving associated objects,  the saving and loading of individual objects, and controlling the object naming conventions.  

-------------------------------------------------------------------------------
Naming
-------------------------------------------------------------------------------
All OpenPNM objects are given a name upon instantiation.  The name can be specified in the initialization statement:

>>> pn = OpenPNM.Network.Cubic(shape=[3,3,3],name='test_net_1')
>>> pn.name
'test_net_1'


The name of an object is stored under the attribute 'name', but it is not possible to *write* to this attribute after instantiation.  OpenPNM prevents renaming objects since many of the interactions between objects are based on object names.  For the same reason it is also not possible to have two objects with the same name associated with a Network.  If a name is not provided, then a name will be automatically generated by appending 5 random characters to the class name (e.g. 'Cubic_riTSw').  The Base class takes care of all these requirements.  

-------------------------------------------------------------------------------
Object Lookup and Retrieval
-------------------------------------------------------------------------------
Every OpenPNM object 'registers' itself with the Network when it is instantiated, which allows the Network to track all objects.  Physics objects also register themselves with the Phase object to which it applies.  When a multicomponent Phase is composed of several 'pure' Phase objects, the pure phases register themselves with the 'mixture' Phase.  All of these associations are necessary to understand who talks to whom.  The Base class contains methods for inspecting the relationships between objects.  It is possible to ask any object to list it's associated ``geometries``, ``phases``, ``physics`` and ``network``, although in many cases the response will be an empty list.  

.. code-block:: python
	
	pn = OpenPNM.Network.Cubic(shape=[3,3,3])
	N2 = OpenPNM.Phases.GenericPhase(network=pn,name='pure_N2')
	O2 = OpenPNM.Phases.GenericPhase(network=pn,name='pure_O2')
	air = OpenPNM.Phases.GenericPhase(network=pn,name='air',phases=[N2,O2])

When asking the 'air' object for its ``phases``, it will return two Phases, indicating that 'air' is a mixture:
>>> air.phases()
['pure_N2', 'pure_O2']

It is also possible to receive a handle to the actual object by sending it's name as an argument:

>>> pn.phases('air')
[<OpenPNM.Phases.__GenericPhase__.GenericPhase object at 0x6586d68>]

It is also possible to remove objects from a simulation using the ``remove_object`` method.  This method accepts both an object name, or the actual object.  It removes all references to the object from all associated objects, including removing and labels that may been generated (i.e. the Geometry object creates a label in the Network indicating where it applies).  

-------------------------------------------------------------------------------
Saving and Loading Objects
-------------------------------------------------------------------------------
Individual objects can be saved to a file using ``save``.  This creates a 'Numpy zip file' with the specified file name in the working directory.  This process saves all of the data from the current object, but *none* of its object associations.  The purpose of this is to save Algorithm objects which can take a significant amount of time to run.  It is also useful for loading in specific Network objects with known properties (for diagnostics), or Networks that were time consuming to generate (like Voronoi).  The ``load`` method is available on instantiated objects, so to load data it is necessary to create an empty object to receive the saved data:

>>> pn = OpenPNM.Network.GenericNetwork()
>>> pn.load('filename')

.. note:: Saving and Loading Entire Simulations

    OpenPNM has the ability to save entire simulations, including all objects, their object associations, all data and all models.  The functionality is found in the Utilities.IO.Load and .Save classes.  OpenPNM saves simulations in a '.pnm' file extension, which is a varient of the '.npz' Numpy zip format.

-------------------------------------------------------------------------------
Logger
-------------------------------------------------------------------------------
All objects have the ability to output logger messages to the console.  Calls to the logger can be found throughout the code for providing warnings and notifications of events.  Logger messages are categorized as either 'debug' (10), 'info' (20), 'warning' (30), 'error' (40), and 'critical' (50), as follows:

>>> pn._logger.debug('this is a diagnostic message')
>>> pn._logger.error('an error has occurred')

It is possible to to suppress all messages below a certain threshold by setting the ``loglevel`` argument when initializing an object:

>>> pn = OpenPNM.Network.Cubic(shape=[3,3,3],loglevel=10)

It is also possible to set the loglevel after instantiation:

>>> pn.set_loglevel(40)

This is most useful for silencing Algorithm objects that might be run multiple times.  

Finally, it is possible to set the name of the logger so that is messages can be clearly identified on the command line. This too is done during instantiation:

>>> pn = OpenPNM.Network.Cubic(shape=[3,3,3],loggername='new_network',loglevel=10)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Core Class
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
The Core class is a child of the Base class, and its methods are all related to the management of data.  All of the main OpenPNM objects are children of Core. It would be equivalent to combine Base and Core into a single class since all inheritance is a direct path from Base, through Core, to the main objects.  The separation is helpful for categorizing what each class does. 

-------------------------------------------------------------------------------
__setitem__
-------------------------------------------------------------------------------
``__setitem_`` is the private method on ``dict`` that is called when the dictionary syntax is used to write values, so ``pn['pore.test'] = 0`` is equivalent to ``pn.__setitem__('pore.test',0)``.  OpenPNM subclasses the ``__setitem__`` method to intercept data and ensure it meets certain criteria before it allowed to be written to the objects.  The two main rules are that (1) all dictionary keys must start with either 'pore' or 'throat', and (2) all data must be of the correct length, either Np or Nt long, where Nt is the number of throats and Np is the number of pores on the object.

.. note:: **Setters and Getters**

    The Core class contains four methods called ``get_data``, ``set_data``, ``get_info`` and ``set_info``.  These methods are an alternative way to read and write property and label values, which might be more familiar to those accustomed to coding in C++.  

-------------------------------------------------------------------------------
Properties and Labels
-------------------------------------------------------------------------------
OpenPNM differentiates between two types of data for pores and throats: 'properties' and 'labels'.  The only difference between these is that 'labels' are Boolean arrays (True / False), while 'properties' are numerical data types.  

The physical details about pores and throats is referred as 'properties', which includes information such as 'pore volume' and 'throat length'.  Properties can be accessed using standard Python dictionary syntax:

>>> pn['pore.index'][1]
1
>>> pn['pore.index'][[0,1]]
array([0, 1])

Writing data also uses dictionary syntax, but with a few caveats due to the fact that OpenPNM has subclassed ``__setitem__`` to 'protect' the integrity of the data. 

>>> pn['pore.index'][10] = 3
>>> pn['pore.index'][10]
3

The main 'caveat' is that data will all be forced to be either Np or Nt long, so the following attempt to write a scalar value will result in a vector of length Np (filled with 1's): 

>>> pn['pore.dummy'] = 1.0

To quickly see a list of all defined 'properties' use ``props``.  You can specify whether only 'pore' or 'throat' properties should be returned, but the default is both:

>>> pn.props()
['pore.index', 'pore.coords', 'throat.conns']
>>> pn.props('pore')
['pore.index', 'pore.coords']

For more details on ``props``, see the method's docstring.  

The second type of information is referred to as 'labels'.  Labels were conceived as a means to dynamically create groups of pores and throats so they could be quickly accessed by the user.  For instance, in a Cubic Network it is helpful to know which pores are on the 'top' surface.  This label is automatically added by the topology generator, so a list of all pores on the 'top' can be retrieved by simply querying which pores possess the label 'top'.  

The only distinction between 'labels' and 'properties' is that 'labels' are boolean masks of True/False.  Thus a True in element 10 of the array 'pore.top' means that the label 'top' has been applied to pore 10.  Adding and removing existing labels to pores and throats is simply a matter of setting the element to True or False.  Creating a new labels is a bit more tricky.  'label' arrays are like any array and they must be defined before they can be indexed, so to apply the label 'dummy_1' to pore 10 requires the following 2 steps:

>>> pn['pore.dummy_1'] = False
>>> pn['pore.dummy_1'][10] = True

Now that this label array has been created and True values have been inserted, it is a simple matter to recall which pores have 'dummy_1' by finding the locations of the True elements:

>>> sp.where(pn['pore.dummy_1'])[0]

OpenPNM provides a more convenient way to perform this query with the ``pores`` and ``throats`` methods that are outlined below.  

The ``labels`` method can be used to obtain a list of all defined labels. This method optionally accepts a list of pores or throats as an argument and returns only the labels that have been applied to the specified locations.  

>>> pn.labels()
['pore.all', 'pore.back', 'pore.bottom', 'pore.front', 'pore.internal', 'pore.left', 'pore.right', 'pore.top', 'throat.all']

``labels`` also has a ``mode`` argument that controls some set-theory logic to the returned list (such as 'union', 'intersection', etc).  See the method's docstring for full details.

-------------------------------------------------------------------------------
Counts and Indices
-------------------------------------------------------------------------------
One of the most common questions about a network is "how many pores and throats does it have?"  This can be answered very easily with the ``num_pores`` and ``num_throats`` methods.  Because these methods are used so often, there are also shortcuts: ``Np`` and ``Nt``.  

>>> pn.num_pores()
27

It is also possible to 'count' only pores that have a certain label:

>>> pn.num_pores('top')
9

These counting methods actually work by counting the number of True elements in the given label array.  

Another highly used feature is to retrieve a list of pores or throats that have a certain label applied to them.  This is of course the entire purpose of 'labels'.  To receive a list of pores on the 'top' of the Cubic network:

>>> pn.pores('top')
array([ 2,  5,  8, 11, 14, 17, 20, 23, 26], dtype=int64)

The ``pores`` and ``throats`` methods both accept a 'mode' argument that allows for set-theory logic to be applied to the query, such as returning 'unions' and 'intersections' of locations. For complete details see the docstring for these methods.  

.. note:: **The Importance of the 'all' Label**

   All objects are instantiated with a 'pore.all' and a 'throat.all' label.  These arrays are essential to the framework since they are used to define how long the 'pore' and 'throat' data arrays must be.  In other words, the ``__setitem__`` method checks to make sure that any 'pore' array is receives is the same length as 'pore.all'.  Moreover, the ``pores``, ``throats``, ``num_pores`` and ``num_throats`` methods all have the label 'all' as their default so if no label is sent 'all' pores or throats are considered.  


-------------------------------------------------------------------------------
Add, Remove and Regenerate Models
-------------------------------------------------------------------------------
The final major functionality that is contained is Core is the ability to add 'models' to the various objects.  Models are one of the most important aspects of OpenPNM, as they allow the user to specify a 'model' for calculating 'pore.volume', rather than just entering values into geometry_object['pore.volume'] array.  Models are also one of the more obscure and confusion parts of OpenPNM. In the remaining documentation, the use of models are demonstrated many times, so section will outline how models and the ``add_model`` method works in general.  

Models are functions included with OpenPNM for calculating a pore or throat property.  For instance, given a list of pore seed values, there is a model for calculating the diameter of the pores based on a specified statistical distribution.  Models are stored in under each module in a folder called 'models'.  For instance, Geometry.models.pore_diameter contains several methods for calculating pore diameters.  

The ``add_model`` method accept 3 main types of arguments.  

(1) It needs to know which pore or throat property does this model calculate.  This is the *propname* argument, and would be 'pore.seed' or 'pore.diameter' for the example above.
(2) It needs the actual function that should be used.  In Python it is possible to pass a function as an argument as easily as passing an integer.  The  *model* argument should be a handle to the function of choice such as Geometry.models.pore_size.sphere.
(3) It can optionally accept an arbitrary number of arguments that will be passed directly to the 'model'.  

These 3 requirements are well demonstrated by the random pore seed model:

.. code-block:: python

	geom = OpenPNM.Geometry.GenericGeometry()  # Creates an empty Geometry object
	mod = OpenPNM.Geometry.models.pore_misc.random
	geom.add_model(propname='pore.seed',model=mod,seed=0)
	
The *propname* and *model* arguments are required by the ``add_model`` method, but the *seed* argument is passed on the model, and it specifies the initialization value for the random number generator.  

The ``add_model`` method actually runs the model and places the data in the dictionary given by *propname*. It also saves the model is a private dictionary (object._models) also under the same *propname*.  When the data is requested from the object it returns the 'static' copy located in the object's dictionary.  In order to recalculate the data the model stored in the private dictionary must be rerun.  This is accomplished with the ``regenerate`` method.  This method takes an optional list of *propnames* that should be regenerated.  It should also be pointed out that models are regenerated in the order that they were added to the object so some care must be taken to ensure that changes in property values cascade through the object correctly.  

It is also possible to remove a model that is not longer needed using ``remove_model``.  This method requires only the *propname* of the model that is to be removed.  After removal of the model, the data (say 'pore.seed') will remain constant upon ``regeneration``.  The actual data can be removed by the usual dictionary methods (pop), or an optional *mode* = 'clean' argument can be sent to the ``remove_model`` method which will delete the model and the data dictionary.  



















